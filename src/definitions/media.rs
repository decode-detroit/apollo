// Copyright (c) 2021 Decode Detroit
// Author: Patton Doyle
// Licence: GNU GPLv3
//
// This program is free software: you can redistribute it and/or modify
// it under the terms of the GNU General Public License as published by
// the Free Software Foundation, either version 3 of the License, or
// (at your option) any later version.
//
// This program is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
//
// You should have received a copy of the GNU General Public License
// along with this program.  If not, see <http://www.gnu.org/licenses/>.

//! This module implements structures to communicate various media parameters.

// Import Gstreamer Library
use gstreamer_video as gst_video;

/// A struct to define a single media track to play
///
/// # Note
///
/// The uri format must follow the URI syntax rules. This means local files must
/// be specified like "file:///absolute/path/to/file.mp4".
///
/// If a file is specified in the loop media field, the channel will loop this
/// media when this media completes. This takes priority over the channel loop
/// media field.
///
#[derive(Clone, PartialEq, Eq, Debug, Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
pub struct MediaCue {
    pub uri: String,                // the location of the video or audio file to play
    pub channel: u32,               // the channel of the video or audio. New media sent to the same channel will replace the old media, starting instantly
    pub loop_media: Option<String>, // the location of media to loop after this media is complete
}

/// A struct to hold the dimensions of a video frame
///
#[derive(Clone, PartialEq, Eq, Debug, Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
pub struct VideoFrame {
    pub window_number: u32, // the application window number for the channel
    pub top: i32,           // the distance (in pixels) from the top of the display
    pub left: i32,          // the distance (in pixels) from the left of the display
    pub height: i32,        // the height of the video
    pub width: i32,         // the width of the video
}

/// Am enum to specify the type of audio output device
///
#[derive(Clone, PartialEq, Eq, Debug, Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
pub enum AudioDevice {
    /// An ALSA audio sink with a device name
    Alsa { device_name: String },

    /// A Pulse Audio sink with a device name
    Pulse { device_name: String },
}

/// A struct to define a single channel to display a media track
///
/// # Note
///
/// If media is specified in the loop media field, the channel will loop this
/// media when the first media completes and anytime no other media has been
/// directed to play on the channel. If no loop media is specified, the channel
/// will hold on the last frame of the most recent media.
///
#[derive(Clone, PartialEq, Eq, Debug, Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
pub struct MediaChannel {
    pub channel: u32, // the channel number
    pub video_frame: Option<VideoFrame>, // the video frame. Defaults to a new application window generated by gstreamer
    pub audio_device: Option<AudioDevice>, // the audio device. Defaults to the system default
    pub loop_media: Option<String>, // the media (video or audio) to loop when no other media is playing
}

/// A helper enum to define the playback state of a channel
///
#[derive(Clone, PartialEq, Eq, Debug, Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
pub enum PlaybackState {
    /// A variant to set the channel to playing
    Playing,

    /// A variant to set the channel to paused
    Paused,
}

/// A struct to define changes to playback state of a channel
///
#[derive(Clone, PartialEq, Eq, Debug, Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
pub struct ChannelState {
    pub channel: u32,               // the channel of the video or audio
    pub state: PlaybackState,       // the new playback state
}

/// A struct to define an application window to hold one or more media channels
///
#[derive(Clone, PartialEq, Eq, Debug, Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
pub struct WindowDefinition {
    pub window_number: u32,         // the channel where the video should be played
    pub fullscreen: bool,               // a flag to indicate whether the window should be fullscreen
    pub dimensions: Option<(i32, i32)>, // the minimum dimensions of the window
}

/// A type to communicate a video stream to the gtk interface
///
#[derive(Clone, PartialEq, Eq, Debug)]
pub struct VideoStream {
    pub channel: u32,               // the channel where the video should be played
    pub window_number: u32,         // the window where the video should be played
    pub allocation: gtk::Rectangle, // the location of the video in the screen
    pub video_overlay: gst_video::VideoOverlay, // the video overlay which should be connected to the video id
}

/// A struct to define a new location for a single video channel
///
#[derive(Clone, PartialEq, Eq, Debug, Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
pub struct ChannelAllocation {
    pub channel: u32, // the channel number
    pub video_frame: VideoFrame, // the video frame
}

/// A type to communicate a new video location to the gtk interface
/// 
#[derive(Clone, PartialEq, Eq, Debug)]
pub struct VideoAllocation {
    pub channel: u32,               // the channel where the video should be played
    pub window_number: u32,         // the window where the video should be played
    pub allocation: gtk::Rectangle, // the location of the video in the screen
}

// Define conversion from a channel location into a video location
impl From<ChannelAllocation> for VideoAllocation {
    fn from(channel_allocation: ChannelAllocation) -> Self {
        Self {
            window_number: channel_allocation.video_frame.window_number,
            channel: channel_allocation.channel,
            allocation:  gtk::Rectangle::new(channel_allocation.video_frame.left, channel_allocation.video_frame.top, channel_allocation.video_frame.width, channel_allocation.video_frame.height),
        }
    }
}
